# Лабораторная работа №5-7

## Отчет

[Отчет в Google Documents](https://docs.google.com/document/d/1enNuWIbzsV80wRqy7cNM3XP-qN5VswKk/edit)

## Цель работы

Целью является приобретение практических навыков в:
* Управлении серверами сообщений (№5)
* Применение отложенных вычислений (№6)
* Интеграция программных систем друг с другом (№7)

## Задание

Реализовать распределенную систему по асинхронной обработке запросов. В данной 
распределенной системе должно существовать 2 вида узлов: «управляющий» и 
«вычислительный». Необходимо объединить данные узлы в соответствии с той топологией, 
которая определена вариантом. Связь между узлами необходимо осуществить при помощи 
технологии очередей сообщений. Также в данной системе необходимо предусмотреть проверку 
доступности узлов в соответствии с вариантом. При убийстве («kill -9») любого вычислительного 
узла система должна пытаться максимально сохранять свою работоспособность, а именно все 
дочерние узлы убитого узла могут стать недоступными, но родительские узлы должны сохранить 
свою работоспособность.

Управляющий узел отвечает за ввод команд от пользователя и отправку этих команд на 
вычислительные узлы.

## Вариант 34 (2-3-3)

**Топология 2.** 
Все вычислительные узлы находятся в дереве общего вида. Есть только один управляющий узел. Чтобы 
добавить новый вычислительный узел к управляющему, то необходимо выполнить команду: 
`create 'id' -1.`

**Набор команд 3.**
Формат команды сохранения значения: `exec 'id' 'subcommand'`
`'subcommand'` – одна из трех команд: `start`, `stop`, `time`.
`start` – запустить таймер
`stop` – остановить таймер
`time` – показать время локального таймера в миллисекундах

**Команда проверки 3.**
Формат команды: `heartbit 'time'`
Каждый узел начинает сообщать раз в `'time'` миллисекунд о том, что он работоспособен. Если от 
узла нет сигнала в течении 4*`'time'` миллисекунд, то должна выводится пользователю строка: 
`Heartbit: node 'id' is unavailable now`, где `'id'` – идентификатор недоступного вычислительного узла.

## Как запустить?

```shell
gcc user.c -o user -lzmq
gcc serv.c -o server -lzmq
./server
```
